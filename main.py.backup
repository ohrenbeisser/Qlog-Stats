#!/usr/bin/env python3
"""
Qlog-Stats - Statistik-Auswertung für Qlog
Hauptprogramm mit Tkinter GUI
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import sys
import os
import webbrowser

from config_manager import ConfigManager
from database import QlogDatabase
from stats_exporter import StatsExporter

try:
    import matplotlib
    matplotlib.use('TkAgg')
    from matplotlib.figure import Figure
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
    MATPLOTLIB_AVAILABLE = True
except ImportError:
    MATPLOTLIB_AVAILABLE = False


class QlogStatsApp:
    """Hauptanwendung für Qlog-Stats"""

    def __init__(self, root):
        """
        Initialisiert die Anwendung

        Args:
            root: Tkinter Root-Fenster
        """
        self.root = root
        self.root.title("Qlog-Stats - QSO Statistik Auswertung")

        self.config = ConfigManager()
        self.db = None
        self.exporter = None

        width, height = self.config.get_window_size()
        self.root.geometry(f"{width}x{height}")

        self._setup_ui()
        self._init_database()

    def _setup_ui(self):
        """Erstellt die Benutzeroberfläche"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Datei", menu=file_menu)
        file_menu.add_command(label="Datenbank-Pfad ändern", command=self._change_db_path)
        file_menu.add_separator()
        file_menu.add_command(label="Beenden", command=self.root.quit)

        stats_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Statistik", menu=stats_menu)
        stats_menu.add_command(label="QSOs nach Ländern", command=self._show_country_stats)
        stats_menu.add_command(label="QSOs nach Bändern", command=self._show_band_stats)
        stats_menu.add_command(label="QSOs nach Modes", command=self._show_mode_stats)
        stats_menu.add_command(label="QSOs nach Jahren", command=self._show_year_stats)

        export_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Export", menu=export_menu)
        export_menu.add_command(label="Als CSV exportieren", command=self._export_csv)
        export_menu.add_command(label="Als TXT exportieren", command=self._export_txt)

        special_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Sonderrufzeichen", menu=special_menu)
        special_menu.add_command(label="Anzeigen", command=self._show_special_callsigns)

        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        filter_frame = ttk.LabelFrame(main_frame, text="Zeitbereich Filter", padding="5")
        filter_frame.pack(fill=tk.X, pady=(0, 10))

        ttk.Label(filter_frame, text="Von:").pack(side=tk.LEFT, padx=(0, 5))
        self.start_date_var = tk.StringVar()
        self.start_date_entry = ttk.Entry(filter_frame, textvariable=self.start_date_var, width=12)
        self.start_date_entry.pack(side=tk.LEFT, padx=(0, 20))

        ttk.Label(filter_frame, text="Bis:").pack(side=tk.LEFT, padx=(0, 5))
        self.end_date_var = tk.StringVar()
        self.end_date_entry = ttk.Entry(filter_frame, textvariable=self.end_date_var, width=12)
        self.end_date_entry.pack(side=tk.LEFT, padx=(0, 20))

        self.apply_filter_btn = ttk.Button(filter_frame, text="Filter anwenden",
                                          command=self._apply_date_filter)
        self.apply_filter_btn.pack(side=tk.LEFT, padx=(0, 10))

        self.reset_filter_btn = ttk.Button(filter_frame, text="Zurücksetzen",
                                          command=self._reset_date_filter)
        self.reset_filter_btn.pack(side=tk.LEFT, padx=(0, 20))

        self.filter_info_label = ttk.Label(filter_frame, text="")
        self.filter_info_label.pack(side=tk.LEFT, padx=(20, 0))

        self.paned_window = tk.PanedWindow(main_frame, orient=tk.HORIZONTAL, sashwidth=5,
                                      sashrelief=tk.RAISED, bg='#cccccc')
        self.paned_window.pack(fill=tk.BOTH, expand=True)

        self.table_frame = ttk.LabelFrame(self.paned_window, text="Tabelle", padding="5")
        self.paned_window.add(self.table_frame, minsize=300)

        tree_scroll_frame = ttk.Frame(self.table_frame)
        tree_scroll_frame.pack(fill=tk.BOTH, expand=True)

        scrollbar_y = ttk.Scrollbar(tree_scroll_frame, orient=tk.VERTICAL)
        scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)

        scrollbar_x = ttk.Scrollbar(tree_scroll_frame, orient=tk.HORIZONTAL)
        scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)

        self.tree = ttk.Treeview(tree_scroll_frame, show='tree headings',
                                yscrollcommand=scrollbar_y.set,
                                xscrollcommand=scrollbar_x.set)
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar_y.config(command=self.tree.yview)
        scrollbar_x.config(command=self.tree.xview)

        self.plot_frame = ttk.LabelFrame(self.paned_window, text="Diagramm", padding="5")
        self.paned_window.add(self.plot_frame, minsize=300)

        if MATPLOTLIB_AVAILABLE:
            self.figure = None
            self.ax = None
            self.canvas = None
            self.canvas_widget = None
            self._create_plot_canvas()
        else:
            no_plot_label = ttk.Label(self.plot_frame, text="matplotlib nicht verfügbar\nBitte installieren: pip install matplotlib")
            no_plot_label.pack(fill=tk.BOTH, expand=True)

        self.current_data = []
        self.current_stats_type = None
        self.sort_reverse = {}
        self.current_columns = []

    def _init_database(self):
        """Initialisiert die Datenbankverbindung"""
        db_path = self.config.get_db_path()

        if not os.path.exists(db_path):
            messagebox.showerror("Fehler",
                               f"Datenbank nicht gefunden:\n{db_path}\n\n"
                               "Bitte Pfad unter 'Datei -> Datenbank-Pfad ändern' anpassen.")
            return

        try:
            self.db = QlogDatabase(db_path)
            self.exporter = StatsExporter(self.config.get_export_directory())

            date_range = self.db.get_date_range()
            self.start_date_var.set(date_range['min_date'])
            self.end_date_var.set(date_range['max_date'])

            self._update_filter_info()

            self.root.after(200, self._show_country_stats)

        except Exception as e:
            messagebox.showerror("Fehler", f"Fehler beim Laden der Datenbank:\n{str(e)}")

    def _update_filter_info(self):
        """Aktualisiert die Filter-Info-Anzeige"""
        start_date = self.start_date_var.get()
        end_date = self.end_date_var.get()

        if self.db:
            total = self.db.get_total_qsos(start_date, end_date)
            self.filter_info_label.config(text=f"QSOs: {total:,}")

    def _apply_date_filter(self):
        """Wendet den Datumsfilter an und aktualisiert die Anzeige"""
        self._update_filter_info()
        if self.current_stats_type == 'country':
            self._show_country_stats()
        elif self.current_stats_type == 'band':
            self._show_band_stats()
        elif self.current_stats_type == 'mode':
            self._show_mode_stats()
        elif self.current_stats_type == 'year':
            self._show_year_stats()

    def _reset_date_filter(self):
        """Setzt den Datumsfilter zurück"""
        if self.db:
            date_range = self.db.get_date_range()
            self.start_date_var.set(date_range['min_date'])
            self.end_date_var.set(date_range['max_date'])
            self._apply_date_filter()

    def _change_db_path(self):
        """Dialog zum Ändern des Datenbank-Pfads"""
        new_path = filedialog.askopenfilename(
            title="Qlog-Datenbank auswählen",
            filetypes=[("SQLite Datenbank", "*.db"), ("Alle Dateien", "*.*")]
        )

        if new_path:
            self.config.set_db_path(new_path)
            if self.db:
                self.db.disconnect()
            self._init_database()

    def _populate_tree(self, columns, data):
        """
        Füllt das Treeview mit Daten

        Args:
            columns: Liste der Spalten-Namen
            data: Liste von Dictionaries mit Daten
        """
        self.tree.delete(*self.tree.get_children())

        self.tree['columns'] = columns
        self.tree.column('#0', width=0, stretch=tk.NO)
        self.current_columns = columns

        for col in columns:
            self.tree.heading(col, text=col.capitalize(), anchor=tk.W,
                            command=lambda c=col: self._sort_tree(c))
            self.tree.column(col, anchor=tk.W, width=200)
            self.sort_reverse[col] = False

        for idx, row in enumerate(data, 1):
            values = [row.get(col, '') for col in columns]
            self.tree.insert('', tk.END, iid=idx, values=values)

    def _sort_tree(self, col):
        """
        Sortiert die Tabelle nach einer Spalte

        Args:
            col: Spaltenname nach dem sortiert werden soll
        """
        items = [(self.tree.set(item, col), item) for item in self.tree.get_children('')]

        try:
            items.sort(key=lambda x: float(x[0]) if x[0].replace('.', '', 1).replace('-', '', 1).isdigit() else x[0].lower(),
                      reverse=self.sort_reverse[col])
        except (ValueError, AttributeError):
            items.sort(key=lambda x: str(x[0]).lower(), reverse=self.sort_reverse[col])

        for index, (_, item) in enumerate(items):
            self.tree.move(item, '', index)

        self.sort_reverse[col] = not self.sort_reverse[col]

        sort_indicator = ' ▼' if self.sort_reverse[col] else ' ▲'
        for c in self.current_columns:
            if c == col:
                self.tree.heading(c, text=c.capitalize() + sort_indicator)
            else:
                self.tree.heading(c, text=c.capitalize())

    def _show_country_stats(self):
        """Zeigt QSOs nach Ländern an"""
        if not self.db:
            return

        try:
            # Diagramm wieder einblenden falls ausgeblendet
            if self.plot_frame not in self.paned_window.panes():
                self.paned_window.add(self.plot_frame, minsize=300)
            self.table_frame.config(text="Tabelle")

            start_date = self.start_date_var.get()
            end_date = self.end_date_var.get()

            data = self.db.get_qsos_by_country(start_date=start_date, end_date=end_date)
            self.current_data = data
            self.current_stats_type = 'country'

            self._populate_tree(['country', 'count'], data)
            self._update_plot()
            self._update_filter_info()

        except Exception as e:
            messagebox.showerror("Fehler", f"Fehler beim Laden der Statistik:\n{str(e)}")

    def _show_band_stats(self):
        """Zeigt QSOs nach Bändern an"""
        if not self.db:
            return

        try:
            # Diagramm wieder einblenden falls ausgeblendet
            if self.plot_frame not in self.paned_window.panes():
                self.paned_window.add(self.plot_frame, minsize=300)
            self.table_frame.config(text="Tabelle")

            start_date = self.start_date_var.get()
            end_date = self.end_date_var.get()

            data = self.db.get_qsos_by_band(start_date=start_date, end_date=end_date)
            self.current_data = data
            self.current_stats_type = 'band'

            self._populate_tree(['band', 'count'], data)
            self._update_plot()
            self._update_filter_info()

        except Exception as e:
            messagebox.showerror("Fehler", f"Fehler beim Laden der Statistik:\n{str(e)}")

    def _show_mode_stats(self):
        """Zeigt QSOs nach Modes an"""
        if not self.db:
            return

        try:
            # Diagramm wieder einblenden falls ausgeblendet
            if self.plot_frame not in self.paned_window.panes():
                self.paned_window.add(self.plot_frame, minsize=300)
            self.table_frame.config(text="Tabelle")

            start_date = self.start_date_var.get()
            end_date = self.end_date_var.get()

            data = self.db.get_qsos_by_mode(start_date=start_date, end_date=end_date)
            self.current_data = data
            self.current_stats_type = 'mode'

            self._populate_tree(['mode', 'count'], data)
            self._update_plot()
            self._update_filter_info()

        except Exception as e:
            messagebox.showerror("Fehler", f"Fehler beim Laden der Statistik:\n{str(e)}")

    def _show_year_stats(self):
        """Zeigt QSOs nach Jahren an"""
        if not self.db:
            return

        try:
            # Diagramm wieder einblenden falls ausgeblendet
            if self.plot_frame not in self.paned_window.panes():
                self.paned_window.add(self.plot_frame, minsize=300)
            self.table_frame.config(text="Tabelle")

            start_date = self.start_date_var.get()
            end_date = self.end_date_var.get()

            data = self.db.get_qsos_by_year(start_date=start_date, end_date=end_date)
            self.current_data = data
            self.current_stats_type = 'year'

            self._populate_tree(['year', 'count'], data)
            self._update_plot()
            self._update_filter_info()

        except Exception as e:
            messagebox.showerror("Fehler", f"Fehler beim Laden der Statistik:\n{str(e)}")

    def _show_special_callsigns(self):
        """Zeigt alle QSOs mit Sonderrufzeichen an"""
        if not self.db:
            return

        try:
            # Diagramm ausblenden
            self.paned_window.forget(self.plot_frame)
            self.table_frame.config(text="Sonderrufzeichen")

            start_date = self.start_date_var.get()
            end_date = self.end_date_var.get()

            data = self.db.get_special_callsigns(start_date=start_date, end_date=end_date)
            self.current_data = data
            self.current_stats_type = 'special'

            columns = ['callsign', 'date', 'time', 'band', 'mode', 'country', 'qrz']

            self.tree.delete(*self.tree.get_children())
            self.tree['columns'] = columns
            self.tree.column('#0', width=0, stretch=tk.NO)
            self.current_columns = columns

            for col in columns:
                display_name = col.upper() if col == 'qrz' else col.capitalize()
                self.tree.heading(col, text=display_name, anchor=tk.W,
                                command=lambda c=col: self._sort_tree(c) if c != 'qrz' else None)
                width = 80 if col in ['date', 'time', 'qrz'] else 100
                self.tree.column(col, anchor=tk.W, width=width)
                self.sort_reverse[col] = False

            for idx, row in enumerate(data, 1):
                values = [
                    row.get('callsign', ''),
                    row.get('date', ''),
                    row.get('time', ''),
                    row.get('band', ''),
                    row.get('mode', ''),
                    row.get('country', ''),
                    'Link'
                ]
                self.tree.insert('', tk.END, iid=idx, values=values)

            self.tree.bind('<Double-Button-1>', self._open_qrz_link)

            self._update_filter_info()

        except Exception as e:
            messagebox.showerror("Fehler", f"Fehler beim Laden der Sonderrufzeichen:\n{str(e)}")

    def _open_qrz_link(self, event):
        """Öffnet QRZ.com für das ausgewählte Rufzeichen"""
        selected = self.tree.selection()
        if selected:
            item = self.tree.item(selected[0])
            values = item['values']
            if values:
                callsign = values[0]
                url = f"https://www.qrz.com/db/{callsign}"
                webbrowser.open(url)

    def _export_csv(self):
        """Exportiert aktuelle Daten als CSV"""
        if not self.current_data:
            messagebox.showwarning("Warnung", "Keine Daten zum Exportieren vorhanden")
            return

        try:
            filepath = self.exporter.export_to_csv(
                self.current_data,
                f'qsos_by_{self.current_stats_type}'
            )
            messagebox.showinfo("Erfolg", f"Export erfolgreich:\n{filepath}")

        except Exception as e:
            messagebox.showerror("Fehler", f"Fehler beim Export:\n{str(e)}")

    def _export_txt(self):
        """Exportiert aktuelle Daten als TXT"""
        if not self.current_data:
            messagebox.showwarning("Warnung", "Keine Daten zum Exportieren vorhanden")
            return

        try:
            title_map = {
                'country': 'QSOs nach Ländern',
                'band': 'QSOs nach Bändern',
                'mode': 'QSOs nach Modes',
                'year': 'QSOs nach Jahren'
            }

            filepath = self.exporter.export_to_txt(
                self.current_data,
                f'qsos_by_{self.current_stats_type}',
                title_map.get(self.current_stats_type, 'Qlog Statistik')
            )
            messagebox.showinfo("Erfolg", f"Export erfolgreich:\n{filepath}")

        except Exception as e:
            messagebox.showerror("Fehler", f"Fehler beim Export:\n{str(e)}")

    def _create_plot_canvas(self):
        """Erstellt das matplotlib Canvas"""
        if not MATPLOTLIB_AVAILABLE:
            return

        self.plot_frame.update_idletasks()
        frame_width = self.plot_frame.winfo_width()
        frame_height = self.plot_frame.winfo_height()

        width = max(frame_width - 30, 200)
        height = max(frame_height - 60, 200)

        width_inch = width / 100
        height_inch = height / 100

        if self.canvas_widget:
            self.canvas_widget.destroy()

        self.figure = Figure(figsize=(width_inch, height_inch), dpi=100)
        self.ax = self.figure.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.figure, master=self.plot_frame)
        self.canvas_widget = self.canvas.get_tk_widget()
        self.canvas_widget.pack(fill=tk.BOTH, expand=True)

    def _update_plot(self):
        """Aktualisiert das eingebettete Diagramm mit den aktuellen Daten"""
        if not MATPLOTLIB_AVAILABLE:
            messagebox.showerror("Fehler",
                               "matplotlib ist nicht installiert.\n"
                               "Bitte installieren mit: pip install matplotlib")
            return

        if not self.current_data:
            return

        try:
            self._create_plot_canvas()

            keys = list(self.current_data[0].keys())
            label_key = keys[0]
            value_key = keys[1]

            limit = min(20, len(self.current_data))
            labels = [str(row[label_key]) for row in self.current_data[:limit]]
            values = [row[value_key] for row in self.current_data[:limit]]

            self.ax.bar(labels, values, color='steelblue')
            self.ax.set_xlabel(label_key.capitalize(), fontsize=10)
            self.ax.set_ylabel(value_key.capitalize(), fontsize=10)

            title_map = {
                'country': f'QSOs nach Ländern (Top {limit})',
                'band': 'QSOs nach Bändern',
                'mode': 'QSOs nach Modes',
                'year': 'QSOs nach Jahren'
            }
            self.ax.set_title(title_map.get(self.current_stats_type, 'Qlog Statistik'), fontsize=11)

            self.ax.tick_params(axis='x', rotation=45, labelsize=8)
            self.ax.tick_params(axis='y', labelsize=9)
            for label in self.ax.get_xticklabels():
                label.set_ha('right')

            try:
                self.figure.tight_layout(pad=2.0)
            except:
                pass

            self.canvas.draw()

        except Exception as e:
            messagebox.showerror("Fehler", f"Fehler beim Erstellen des Diagramms:\n{str(e)}")

    def run(self):
        """Startet die Anwendung"""
        self.root.mainloop()


def main():
    """Hauptfunktion"""
    root = tk.Tk()
    app = QlogStatsApp(root)
    app.run()


if __name__ == '__main__':
    main()
